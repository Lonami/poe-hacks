# Imports
import abc
import ctypes
import os
import sys
import time
from tempfile import gettempdir
from urllib.request import urlretrieve

from pip import _internal as pip

# Automatically install missing modules
try:
    import curses
except ImportError:
    name = 'curses-2.2-cp{0}-cp{0}m-win{1}.whl'.format(
        ''.join(map(str, sys.version_info[:2])),
        '_amd64' if sys.maxsize > 2**32 else '32'
    )
    url = f'https://download.lfd.uci.edu/pythonlibs/q5gtlas7/{name}'
    file = os.path.join(gettempdir(), name)
    try:
        urlretrieve(url, file)
        pip.main(['install', file])
    finally:
        os.remove(file)

    import curses


# Set later by curses
screen = None


# Constants
NORMAL_HL = curses.A_NORMAL
TITLE_HL = curses.A_BOLD
SELECTED_HL = curses.A_REVERSE
POE_KEY = r'bin\poe.key'


# Settings generated by the application
class Settings:
    class Decoration:
        def __init__(self, p1=(0, 0), c1=0, p2=(0, 0), c2=0):
            self.p1 = p1
            self.c1 = c1
            self.p2 = p2
            self.c2 = c2

        def __str__(self):
            return ' '.join(map(str, (
                *self.p1, self.c1,
                *self.p2, self.c2
            )))

        @classmethod
        def load(cls, line):
            x1, y1, c1, x2, y2, c2 = list(map(int, line.split(maxsplit=6 - 1)))
            return cls((x1, y1), c1, (x2, y2), c2)

    class Action:
        def __init__(self, *, enabled=1, flask=0, delay=0, skill=0, point=(0, 0), color=0, desc=''):
            self.enabled = enabled
            self.flask = flask
            self.delay = delay
            self.skill = skill
            self.point = point
            self.color = color
            self.desc = desc

        def print(self):
            result = '[x] ' if self.enabled == 1 else '[ ] '
            if self.flask == 0:
                result += 'logout '
            else:
                result += f'use flask {chr(self.flask)} '

            if self.delay == 0:
                result += 'immediately on '
            else:
                result += f'every {self.delay}ms on '

            if self.skill != 0:
                result += f'skill {chr(self.skill)}'
            elif self.point[0] < 200:
                result += 'life change'
            else:
                result += 'mana change'

            if self.desc:
                result += f': {self.desc}'
            else:
                result += ' (no description)'

            return result

        def __str__(self):
            return ' '.join(map(str, (
                self.enabled,
                self.flask,
                self.delay,
                self.skill,
                *self.point,
                self.color,
                self.desc
            )))

        @classmethod
        def load(cls, line):
            parts = line.split(maxsplit=8 - 1)
            parts[0:7] = map(int, parts[0:7])
            return cls(
                enabled=parts[0],
                flask=parts[1],
                delay=parts[2],
                skill=parts[3],
                point=parts[4:6],
                color=parts[6],
                desc=parts[7].strip() if len(parts) > 7 else ''
            )

    def __init__(self, file):
        self.logout_key = 0
        self.decoration = self.Decoration()
        self.actions = []
        self.file = file
        try:
            with open(file) as fd:
                self.logout_key = int(fd.readline())
                self.decoration = self.Decoration.load(fd.readline())
                self.actions = [self.Action.load(fd.readline()) for _ in range(int(fd.readline()))]
        except ValueError as e:
            print('malformed file ', e)
            exit(1)
        except OSError:
            pass

    def __str__(self):
        return '\n'.join(map(str, (
            self.logout_key,
            self.decoration,
            len(self.actions),
            *self.actions,
            ''
        )))

    def save(self):
        with open(self.file, 'w') as fd:
            fd.write(str(self))


settings = Settings(POE_KEY)


# Windows stuff
class POINT(ctypes.Structure):
    _fields_ = [('x', ctypes.c_long), ('y', ctypes.c_long)]

    def __str__(self):
        return f'{self.x} {self.y}'


def wait_mouse(which):
    # 1 for left, 2 for right
    while True:  # wait down
        time.sleep(0.01)
        if ctypes.windll.user32.GetAsyncKeyState(which):
            break

    while True:  # wait release
        time.sleep(0.01)
        if not ctypes.windll.user32.GetAsyncKeyState(which):
            break

    pt = POINT()
    ctypes.windll.user32.GetCursorPos(ctypes.byref(pt))
    return pt.x, pt.y


def get_color(x, y):
    # returns zbgr
    return ctypes.windll.gdi32.GetPixel(ctypes.windll.user32.GetDC(0), x, y)


# Make using curses nicer
class Menu:
    def __init__(self, title, options):
        self.title = title
        self.options = options
        self.current = 0

    def run(self, menu_stack=None):
        menu_stack = (menu_stack or []) + [self.title]
        while self.step(menu_stack):
            pass

    def step(self, menu_stack):
        screen.clear()
        screen.addstr(0, 0, ' > '.join(menu_stack), TITLE_HL)
        for i, option in enumerate(self.options):
            if isinstance(option, Menu):
                text = f'* {option.title}'
            elif isinstance(option, Action):
                text = f'* {option.name}'
            else:
                text = f'* ???'

            screen.addstr(i + 2, 2, text, [NORMAL_HL, SELECTED_HL][self.current == i])
        screen.addstr(len(self.options) + 3, 0, 'Up    / Down      : change selection')
        screen.addstr(len(self.options) + 4, 0, 'Left  / Backspace : go back once')
        screen.addstr(len(self.options) + 5, 0, 'Right / Enter     : select option')

        screen.move(self.current + 2, 2)
        screen.refresh()

        key = screen.getch()
        if key == curses.KEY_DOWN:
            self.current = (self.current + 1) % len(self.options)
        elif key == curses.KEY_UP:
            self.current = (self.current - 1) % len(self.options)
        elif key in (curses.KEY_RIGHT, curses.KEY_ENTER):
            self.options[self.current].run(menu_stack)
        elif key in (curses.KEY_LEFT, curses.KEY_BACKSPACE):
            return False
        else:
            self.fallback(key)

        return True

    def fallback(self, key):
        pass


class ActionMenu(Menu):
    def __init__(self, title):
        super().__init__(f'{title} (D to Delete)', [])

    def step(self, menu_stack):
        self.options = [ActionToggle(a) for a in settings.actions]
        return super().step(menu_stack)

    def fallback(self, key):
        if chr(key) in 'Dd':
            if settings.actions:
                del settings.actions[self.current]
                if settings.actions and self.current == len(settings.actions):
                    self.current -= 1


class Action:
    def __init__(self, name, save_delay=1):
        self.name = name
        self.line = 0
        self.save_delay = save_delay

    def run(self, menu_stack=None):
        menu_stack = (menu_stack or []) + [self.name]

        screen.clear()
        screen.addstr(0, 0, ' > '.join(menu_stack), TITLE_HL)
        self.line = 2
        self.act()
        settings.save()
        if self.save_delay > 0:
            self.write('Good! Saving...')
            time.sleep(self.save_delay)

    def write(self, text):
        screen.addstr(self.line, 2, text)
        screen.refresh()
        self.line += 1

    def getch(self):
        try:
            curses.echo()
            return ord(chr(screen.getch()).upper())
        finally:
            curses.noecho()

    @staticmethod
    def getline():
        try:
            curses.echo()
            return screen.getstr().decode().strip()
        finally:
            curses.noecho()

    @abc.abstractmethod
    def act(self):
        pass


class LogoutKeyAction(Action):
    def act(self):
        self.write(f'Press the key to use to logout (old was {chr(settings.logout_key)}): ')
        settings.logout_key = self.getch()


class ChangeDecorAction(Action):
    def act(self):
        self.write(f'Right-click on a decoration point (old was {settings.decoration.p1})... ')
        p1 = wait_mouse(2)
        c1 = get_color(*p1)
        self.write(f'Right-click on another decoration point (old was {settings.decoration.p2})... ')
        p2 = wait_mouse(2)
        c2 = get_color(*p2)
        settings.decoration = Settings.Decoration(p1, c1, p2, c2)


class AutoLogoutScreen(Action):
    def act(self):
        self.write('Enter a description: ')
        desc = self.getline()
        self.write('Right-click on the point to detect... ')
        p = wait_mouse(2)
        c = get_color(*p)
        settings.actions.append(Settings.Action(
            desc=desc,
            point=p,
            color=c
        ))


class AutoFlaskScreen(Action):
    def act(self):
        self.write('Enter a description: ')
        desc = self.getline()
        self.write('Press the key with the flask to use: ')
        flask = self.getch()
        self.write('Enter the delay (in ms) between flask uses: ')
        try:
            delay = int(self.getline())
        except ValueError:
            delay = 1000
        self.write('Right-click on the life/mana point to detect... ')
        p = wait_mouse(2)
        c = get_color(*p)
        settings.actions.append(Settings.Action(
            flask=flask,
            delay=delay,
            desc=desc,
            point=p,
            color=c
        ))


class AutoFlaskOnSkill(Action):
    def act(self):
        self.write('Enter a description: ')
        desc = self.getline()
        self.write('Press the key with the flask to use: ')
        flask = self.getch()
        self.write('Enter the delay (in ms) between flask uses: ')
        delay = self.getline()
        self.write('Press the key with the skill: ')
        skill = self.getch()
        settings.actions.append(Settings.Action(
            flask=flask,
            delay=delay,
            skill=skill,
            desc=desc
        ))


class ActionToggle(Action):
    def __init__(self, action):
        super().__init__(action.print(), save_delay=0)
        self.action = action

    def act(self):
        self.action.enabled = 1 - self.action.enabled


def main(scr):
    global screen
    screen = scr
    Menu('Main menu', [
        LogoutKeyAction('Manage logout key'),
        ChangeDecorAction('Manage decoration'),
        Menu('Manage actions', [
            ActionMenu('Edit existing actions'),
            AutoLogoutScreen('Add auto-logout on screen point change'),
            AutoFlaskScreen('Add auto-flask on screen point change'),
            AutoFlaskOnSkill('Add auto-flask on skill use')
        ])
    ]).run()


if __name__ == '__main__':
    curses.wrapper(main)
